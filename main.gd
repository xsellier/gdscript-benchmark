@tool
extends Node

var outfile
var startusec = 0
var elapsed = 0
var testvar = 0
var bigarray = []

func fileinit():
  outfile = File.new()
  if outfile.open("res://README.md", File.WRITE) != 0:
    print("ERROR OPENING FILE")

    return 1

  for line in [
      "# GDScript Syntax Benchmarks",
      "",
      "Speed comparisons of various syntax alternatives within the GDScript language (Godot game engine).  All code is within [benchmarks.gd](benchmarks.gd), including funcs referenced in results table.",
      "",
      "__SEE THE END OF THIS README FOR THE RESULTS TABLE__",
      "",
      "",
      "## To Run Tests Yourself",
      "",
      "* Open the project in Godot",
      "* Click the lone node in the Scene/Node panel",
      "* Click the unchecked box in the Inspector for the exported variable 'Click To Run'",
      "* Wait several seconds for the tests to run (Godot editor may appear frozen during this time)",
      "",
      "The script is a 'tool' and clicking this exported variable will trigger a setget function which actually runs the tests.  The results will be printed in the standard output and written to your disk as README.md (clobbering the existing README.md)",
      "",
      "## Contributors",
      "",
      "Please only add [benchmarks.gd](benchmarks.gd) to your commits.  This entire readme file is automaticaly generated by the script, so please do not commit changes to the readme itself.  Thanks!",
      "",
      "## Results",
      "",
      "```Godot version: %s```" % [ Engine.get_version_info().string ],
      "",
      ]:
    outfile.store_string("%s\n" % line)
  return 0

func printwrite(s):
  print(s)
  outfile.store_string("%s\n" % s)

func _ready():
  run()

func run():
  print()
  if fileinit():
    print("ERROR OPENING FILE")
    return 1
  bigarray = []
  bigarray.resize(1e6)
  timeit("warmup", true)

  compare_funcs_time("c_add_child", "c_add_child_deferred")
  outfile.close()

func assign_startusec():
  startusec = Time.get_ticks_usec()

func assign_elapsed():
  # do this first for accuracy
  elapsed = Time.get_ticks_usec() - startusec

    # then check that startusec had been properly assigned
  assert(startusec != 0)

  # reset startusec
  startusec = 0

func timeit(funcname, quiet = false):
  assign_startusec()
  call(funcname)
  assign_elapsed()

  if not quiet:
    print("%s took %d usec" % [funcname, elapsed])

func compare_funcs_time(funcname1, funcname2):
  # for fn in [funcname1, funcname2]:
  #   # for padding output strings
  #   assert(fn.length() <= 15)

  timeit(funcname1, true)
  var elapsed1 = elapsed
  timeit(funcname2, true)
  var elapsed2 = elapsed
  var e1_over_e2 = float(elapsed1) / float(elapsed2)
  var fasterfunc
  var slowerfunc
  var fasterelapsed
  var slowerelapsed
  if elapsed1 > elapsed2:
    fasterfunc = funcname2
    slowerfunc = funcname1
    fasterelapsed = elapsed2
    slowerelapsed = elapsed1
  else:
    fasterfunc = funcname1
    slowerfunc = funcname2
    fasterelapsed = elapsed1
    slowerelapsed = elapsed2
  var result = "%15s  *** %3.f%% faster than ***  %-15s (%.3f vs %.3f msec)" % [fasterfunc, 100.0*(float(slowerelapsed)/float(fasterelapsed) -1.0), slowerfunc, 1000.0*fasterelapsed/1e6, 1000.0*slowerelapsed/1e6]
  printwrite("    " + result)

func warmup():
  for i in range(1e6): pass

func c_add_child():
  var node = Node.new()

  call_deferred('add_child', node)
  node.connect('tree_entered', node.queue_free)

func c_add_child_deferred():
  var node = Node.new()

  add_child_deferred(node)
  node.connect('tree_entered', node.queue_free)

